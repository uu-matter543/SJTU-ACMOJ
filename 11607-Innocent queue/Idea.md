# 11607 解题思路

直接方法就是维护队列，每次入队时遍历队列里面是否有同团体的人

但是这样时间复杂度太大肯定过不了，问题在哪呢？

很明显，找同团体的人使用队列遍历的方法非常麻烦，优化方法就是用哈希表来存储每个团体里面最后一个人的位置，之后入队时用哈希表来找本团体最后一个人会更快

此时由于会有出队的人，使用顺序存储需要移动整个队列的元素和哈希表，所以采用了链式结构，定义结构体保存：每个人的编号、每个人所属团体ID、下个结点的位置，链表抽象为头结点和尾结点，分别用于出队和一般情况下的入队

入队时，首先去哈希表找有没有本团体的成员，有的话就插队并更新哈希表，没有的话就老老实实排在队列后面。**注意，这里哈希表里没有本团体的成员是有两个映像的，一是哈希表没有对应的键值，二是这个团体本来有成员在队列里，但是他们都走了，导致哈希表键对应的值为空**，所以能找到本团体的成员的条件是有两个的，在哈希表找到团体之后还要看末位置指针是否为空。至于插队和正常排队，都是链表的基本操作

出队时，首先看队列是否为空，为空输出-1，不为空就输出队首的人的编号，之后修理哈希表，如果这个人是这个团体的最后一个人，就把哈希表里对应的团体改成空指针

最后清理一下空间，避免 `Memory Leak` 问题
